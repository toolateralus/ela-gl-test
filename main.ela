#import gl;
#import file;
#import format;

Vertex :: struct {
  position: Vec3,
  normal:   Vec3,
  texcoord: Vec2,
}

impl Vertex {
  new :: fn(position: Vec3, normal: Vec3, texcoord: Vec2) -> #self {
    return .{
      position: position,
      normal: normal,
      texcoord: texcoord,
    }
  }
}

impl Vec3 {
  new :: fn(x: f32, y, z) -> #self {
    return .{
      x: x,
      y: y,
      z: z,
    }
  }
}

impl Vec2 {
  new :: fn(x: f32, y) -> #self {
    return .{
      x: x,
      y: y,
    }
  }
}

impl List![Field] {
  order_by :: fn(self, predicate: fn* (Field*, Field*) -> bool) -> List![Field] {
    new_list := self.clone();
    for i in 0..new_list.length {
      for j in (i+1)..new_list.length {
        if predicate(&new_list.data[i], &new_list.data[j]) {
          temp := new_list.data[i];
          new_list.data[i] = new_list[j];
          new_list.data[j] = temp;
        }
      }
    }
    return new_list;
  }
}

GeneralBuffer :: struct![T] {
  vao: s32,
  vbo: s32,
  descriptor: String,
}

impl![T] GeneralBuffer![T] {
  new :: fn() -> #self {
    buffer: #self;
    glGenVertexArrays(1, &buffer.vao);
    glGenBuffers(1, &buffer.vbo);
    type := #type(T);
    index := 0;
    stride := sizeof(T);

    glBindVertexArray(buffer.vao);
    glBindBuffer(GL::ARRAY_BUFFER, buffer.vbo);

    descriptor: String_Builder;
    // descriptor.append("buffer descriptor:\n");
    // descriptor.append_then_free(format("  Info { vao:   %, vbo:    % }\n", .[any::new(&buffer.vao), any::new(&buffer.vbo)]));

    defer { 
      descriptor.deinit();
    }

    ordered_fields := type.fields.order_by(fn(a: Field*, b) -> bool {
      return a.offset < b.offset;
    });

    for field in ordered_fields {
      // descriptor.append_then_free(format("  % { index: %, offset: % }\n", .[any::new(&field.type.name), any::new(&index), any::new(&field.offset)]));
      if field.type.is_float() {
        glVertexAttribPointer(index, field.size as s32, GL::FLOAT, false, stride, field.offset as void*);
      } else if field.type.is_integral() {
        glVertexAttribIPointer(index, field.size as s32, GL::INT, stride, field.offset as void*);
      } else if field.type == #type(Mat4) {
        for i in 0..4 {
          offset := field.offset + i * sizeof(Vec4);
          // descriptor.append_then_free(format("    f32 { index: %, offset: % }\n", .[any::new(&index), any::new(&offset)]));
          glVertexAttribPointer(index, 4, GL::FLOAT, false, stride, offset as void*);
          glEnableVertexAttribArray(index);
          glVertexAttribDivisor(index, 1);
          index += 1;
        }
        continue;
      } else if field.type == #type(Vec4) {
        glVertexAttribPointer(index, 4, GL::FLOAT, false, stride, field.offset as void*);
      } else if field.type == #type(Vec3) {
        glVertexAttribPointer(index, 3, GL::FLOAT, false, stride, field.offset as void*);
      } else if field.type == #type(Vec2) {
        glVertexAttribPointer(index, 2, GL::FLOAT, false, stride, field.offset as void*);
      } else {
        println("unsupported type in GeneralBuffer, T can only contain (floats|ints|Vec2|Vec3|Vec4|Mat4)");
      }
      glEnableVertexAttribArray(index);
      index ++;
    }

    buffer.descriptor = descriptor.get_string();

    glBindVertexArray(0);
    glBindBuffer(GL::ARRAY_BUFFER, 0);

    return buffer;
  }

  bind_and_buffer_data :: fn(self, slice: Slice![T]) {
    glBindVertexArray(self.vao);
    glBindBuffer(GL::ARRAY_BUFFER, self.vbo);
    glBufferData(GL::ARRAY_BUFFER, sizeof(Vertex) * slice.length, slice.data, GL::STATIC_DRAW);
  }

  unbind :: fn(self) {
    glBindVertexArray(0);
    glBindBuffer(GL::ARRAY_BUFFER, 0);
  }
}

NUM_VERTICES :: 36;

cube :: fn(scale: f32) -> Vertex[] {
  return Vertex[]::init(.[
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, 0.0, -scale), Vec2::new(0.0, 0.0)),

    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, 0.0, scale), Vec2::new(0.0, 0.0)),

    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(-scale, 0.0, 0.0), Vec2::new(scale, 0.0)),

    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(scale, 0.0, 0.0), Vec2::new(scale, 0.0)),

    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new( (scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2),  (scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2), -(scale / 2), -(scale / 2)), Vec3::new(0.0, -scale, 0.0), Vec2::new(0.0, scale)),

    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(0.0, scale)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(scale, scale)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new( (scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(scale, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2),  (scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(0.0, 0.0)),
    Vertex::new(Vec3::new(-(scale / 2),  (scale / 2), -(scale / 2)), Vec3::new(0.0, scale, 0.0), Vec2::new(0.0, scale))
  ]);
}

print_vertices :: fn(vertices: Slice![Vertex]) {
  printf("vertices = ["c);
  for i in 0..vertices.length {
    vert := vertices.data[i];
    printf("  pos: %.1f %.1f %.1f, normal: %.1f %.1f %.1f, texcoord: %.1f %.1f\n"c,
      vert.position.x, vert.position.y, vert.position.z,
      vert.normal.x, vert.normal.y, vert.normal.z,
      vert.texcoord.x, vert.texcoord.y);
    }
  printf("]\n"c);
}

main :: fn () {
  vertices := cube(1.0);

  vertex, _ := File::read_all("shader/vert.glsl");
  fragment, _1 := File::read_all("shader/frag.glsl");
  
  window := Window::create(800, 600, "Привет, Мир!");

  glEnable(GL::DEPTH_TEST);
  glClearColor(0.005, 0.005, 0.005, 1.0);
  
  buffer := GeneralBuffer![Vertex]::new();
  print_vertices(vertices.as_slice(0..NUM_VERTICES));

  shader := Shader::create(vertex, fragment);
  vertex.deinit();
  fragment.deinit();
  shader.use();
  
  defer vertices.deinit();

  println(buffer.descriptor);

  fov := 45.0;
  aspect_ratio := 800.0 / 600.0;
  near := 0.1;
  far := 100.0;

  camera := Camera::new(Vec3::up(), fov, aspect_ratio, near, far);
  camera.position = Vec3::new(0.0, 0.0, 3.0);
  camera.target = .{};

  model_position := Vec3::new(0.0, 0.0, -5.0);
  model_rotation := Vec3::new(0.0, 5.0, 0.0);

  lightColor := Vec3::new(0.0, 1.0, 1.0);
  objectColor := Vec3::new(1.0, 0.25, 0.31);

  while !window.should_close() {
    buffer.bind_and_buffer_data(.{
      data: vertices.data,
      length: NUM_VERTICES
    });

    model_rotation.y = model_rotation.y + 0.1;

    { // Lighting uniforms
      lightPos := model_position + Vec3::new(0.0, 1.0, 1.0);

      shader.set_vec3("lightPos", &lightPos);
      shader.set_vec3("lightColor", &lightColor);
      shader.set_vec3("objectColor", &objectColor);
      shader.set_float("specularStrength", 1.5);
      shader.set_float("ambientStrength", 1.0);
    }

    {
      model := Mat4::translation(model_position) * Mat4::rotation(model_rotation);
      camera.target = model_position;
      camera.update();
      viewPos := camera.view.get_translation();
      shader.set_vec3("viewPos", &viewPos);
      shader.set_mat4("model", &model);
      shader.set_mat4("view", &camera.view);
      shader.set_mat4("projection", &camera.projection);
    }

    glClear(GL::COLOR_BUFFER_BIT | GL::DEPTH_BUFFER_BIT);
    glDrawArrays(GL::TRIANGLES, 0, NUM_VERTICES);

    window.present();
  }
}